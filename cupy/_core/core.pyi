from collections.abc import Iterator
from typing import Any, Generic

from _typeshed import StrOrBytesPath, SupportsWrite
from typing import overload
from typing_extensions import Self

from cupy import dtype
from cupy._core.flags import Flags
from cupy.typing._types import NDArray, DTypeLike
from cupy.typing._internal import (
    _DTypeT_co,
    _OrderKACF,
    _DTypeLike,
    _ScalarT,
    _ShapeLike,
    _ArrayT,
)

class ndarray(Generic[_DTypeT_co]):
    def __cuda_array_interface__(self) -> dict[str, Any]: ...
    def is_host_accessible(self) -> bool: ...
    @property
    def flags(self) -> Flags: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @shape.setter
    def shape(self, newshape: _ShapeLike) -> None: ...
    def strides(self) -> tuple[int, ...]: ...
    def ndim(self) -> int: ...
    def itemsize(self) -> int: ...
    def nbytes(self) -> int: ...
    @property
    def T(self) -> ndarray[_DTypeT_co]: ...
    @property
    def mT(self) -> ndarray[_DTypeT_co]: ...
    @property
    def flat(self: NDArray[_ScalarT]) -> Iterator[_ScalarT]: ...
    def item(self: NDArray[_ScalarT]) -> _ScalarT: ...
    def tolist(self: NDArray[_ScalarT]) -> list[Any]: ...
    def tobytes(self, order: _OrderKACF = ...) -> bytes: ...
    def tofile(
        self, fid: StrOrBytesPath, sep: str = ..., format: str = ...
    ) -> None: ...
    def dump(self, file: StrOrBytesPath | SupportsWrite[bytes]) -> None: ...
    def dumps(self) -> bytes: ...
    @overload
    def astype(
        self,
        dtype: _DTypeLike[_ScalarT],
        order: _OrderKACF = ...,
        copy: bool = ...,
    ) -> ndarray[dtype[_ScalarT]]: ...
    @overload
    def astype(
        self,
        dtype: DTypeLike,
        order: _OrderKACF = ...,
        copy: bool = ...,
    ) -> ndarray[dtype]: ...
    def copy(self, order: _OrderKACF = ...) -> Self: ...
    @overload
    def view(self) -> Self: ...
    @overload
    def view(self, dtype: DTypeLike) -> ndarray[dtype]: ...
    @overload
    def view(
        self, dtype: _DTypeLike[_ScalarT]
    ) -> ndarray[dtype[_ScalarT]]: ...
    @overload
    def view(self, type: type[_ArrayT]) -> _ArrayT: ...
    @overload
    def view(self, dtype: DTypeLike, type: type[_ArrayT]) -> _ArrayT: ...
    def fill(self, value: Any) -> None: ...
